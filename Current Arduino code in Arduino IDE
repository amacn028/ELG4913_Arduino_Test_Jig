#include <SPI.h>
int handshake_input =2;
int handshake_output =7;
int analogMeasurements =0;
int ESP32_to_Arduino_transaction_flag =0;
int Arduino_to_ESP32_transaction_flag =0;
volatile unsigned long stage_counter =0;
volatile unsigned long lastInterruptTime =0;
const unsigned long debounceTime = 5000000;
int iteration_counter=0;
volatile byte dataToSend[11] = {0x11, 0x22, 0x33, 0x44, 0x55,0x12,0x13,0x14,0x15,0x16,0x17};
volatile byte index = 0;

void handshake_input_toggle(){
  unsigned long currentTime = micros();
  if((currentTime-lastInterruptTime) >= debounceTime){
    stage_counter++;
    lastInterruptTime = currentTime;
  }
}

typedef struct SPI_STRUCT{
  
  
  

  byte temp_measurement;
  byte D_register1;
  byte B_register1;
  byte D_register2;
  byte B_register2;
  byte A0;
  byte A1;
  byte A2;
  byte A3;
  byte A4;
  byte A5;
  
  
};
SPI_STRUCT struct1;


void setup() {
  Serial.begin(115200);
  DDRD = DDRD | B11111110;  // confiure pins D0,D2-D7 as outputs
                          // without changing the value of pins 0 & 1, which are RX & TX
  
  DDRB = DDRB | B11111100;  // confiure pins D8-D13 as outputs
                          // without changing the value of bits 6 & 7 of the register ( crystal osc. pins) which are unusable.
  
  
  
  PORTD=B10000000; // set pins D2-D7 to LOW
    //this should read as: 1 ie 00000001
  PORTB=B10000000; // set pins D8-D13 to LOW
    //this should read as: 0 ie 00000000
  
  struct1.D_register2 = PIND;
  //struct1.D_register = 0x0E;
  struct1.B_register2 = PINB;
  //struct1.B_register = 0x02;
  PORTD=B11111000; // set pins D2-D7 to HIGH , no control on D1:D0 which default are b'01
  //this should read as: 11111101
  PORTB=B00111111; // set pins D8-D13 to HIGH , 
    // this should read as: 00111111
  struct1.D_register1 = PIND;
  //struct1.D_register = 0x0E;
  struct1.B_register1 = PINB;
  //struct1.B_register = 0x02;
  //dummy byte temp_measurement for now
  struct1.temp_measurement=0x33;
  dataToSend[0]=struct1.temp_measurement;
  dataToSend[1]=struct1.B_register1;
  dataToSend[2]=struct1.B_register2;
  dataToSend[3]=struct1.D_register1;
  dataToSend[4]=struct1.D_register2;
  
  //dataToSend[5] = {struct1.temp_measurement,struct1.B_register1,struct1.B_register2,struct1.D_register1,struct1.D_register2};
  pinMode(MISO, OUTPUT);  // Slave sends data on MISO
  SPCR |= _BV(SPE);       // Enable SPI in slave mode
  SPI.attachInterrupt();  // Enable SPI interrupt
  pinMode(handshake_input,INPUT);
  pinMode(handshake_output,OUTPUT);
  digitalWrite(handshake_output,HIGH); //initiate stage 1
  attachInterrupt(digitalPinToInterrupt(handshake_input),handshake_input_toggle,CHANGE);
}

ISR(SPI_STC_vect) {
  // When master sends a byte, send the next byte in response
  if(index<11){
  SPDR = dataToSend[index];
  index++;
  }
  else{
    SPDR = 0x00;//dummy byte 
  }
}

void loop() {
  // You can update dataToSend[] here if needed dynamically
 
  digitalWrite(handshake_output,LOW);//initiate stage2
  if(stage_counter ==2){
    Serial.print("temp_sensor_measurement: ");
    Serial.println(struct1.temp_measurement,HEX);
    Serial.print("B_register1: ");
    Serial.println(struct1.B_register1,HEX);
    Serial.print("B_register2: ");
    Serial.println(struct1.B_register2,HEX);
    Serial.print("D_register1: ");
    Serial.println(struct1.D_register1,HEX);
    
    Serial.print("D_register2: ");
    Serial.println(struct1.D_register2,HEX);
    digitalWrite(handshake_output,HIGH);
    }
  if(stage_counter ==3){
    //may need some conditioning code ,depends if logic shifter corrects discrepancy
    //" if within bounds,assign struct1.Ax = 254"
    analogMeasurements=analogRead(A0);
    analogMeasurements= map(analogMeasurements,0,1023,0,255);
    if(analogMeasurements>=135){
    struct1.A0=analogMeasurements;
    }
    Serial.print("A0: ");
    Serial.println(analogMeasurements);
    delay(22);
    analogMeasurements=analogRead(A1);
    analogMeasurements= map(analogMeasurements,0,1023,0,255);
    if(analogMeasurements>=135){
    struct1.A1=analogMeasurements;
    }
    
    Serial.print("A1: ");
    Serial.println(analogMeasurements);
    delay(22);
    analogMeasurements=analogRead(A2);
    analogMeasurements= map(analogMeasurements,0,1023,0,255);
    
    if(analogMeasurements>=135){
    struct1.A2=analogMeasurements;
    }
    Serial.print("A2: ");
    Serial.println(analogMeasurements);
    delay(22);
    analogMeasurements=analogRead(A3);
    analogMeasurements= map(analogMeasurements,0,1023,0,255);
    
    if(analogMeasurements>=135){
    struct1.A3=analogMeasurements;
    }
    Serial.print("A3: ");
    Serial.println(analogMeasurements);
    delay(22);
    analogMeasurements=analogRead(A4);
    analogMeasurements= map(analogMeasurements,0,1023,0,255);
    if(analogMeasurements>=135){
    struct1.A4=analogMeasurements;
    }

    Serial.print("A4: ");
    Serial.println(analogMeasurements);
    delay(22);
    analogMeasurements=analogRead(A5);
    analogMeasurements= map(analogMeasurements,0,1023,0,255);
    
    if(analogMeasurements>=135){
    struct1.A5=analogMeasurements;
    }
    Serial.print("A5: ");
    Serial.println(analogMeasurements);
    delay(22);
    dataToSend[5]=struct1.A0;
    dataToSend[6]=struct1.A1;
    dataToSend[7]=struct1.A2;
    dataToSend[8]=struct1.A3;
    dataToSend[9]=struct1.A4;
    dataToSend[10]=struct1.A5;
    digitalWrite(handshake_output,LOW);
  }
  if(stage_counter ==5){
    Serial.println("PWM code here");
  }
  ESP32_to_Arduino_transaction_flag=digitalRead(handshake_input);
  Arduino_to_ESP32_transaction_flag=digitalRead(handshake_output);
  Serial.print("ESP32_to_Arduino_transaction_flag: ");
  Serial.println(ESP32_to_Arduino_transaction_flag);
  Serial.print("Arduino_to_ESP32_transaction_flag: ");
  Serial.println(Arduino_to_ESP32_transaction_flag);
  Serial.print("Stage_counter: ");
  Serial.println(stage_counter);
  
  delay(1000);
}
